# 중력 작용
## 문제 설명
- 어떤 트리가 존재한다.
- 이 트리에 두 종류의 쿼리를 넣어서 그 결과를 보려고 한다.
- 첫 번째 쿼리는 주어진 번호의 노드를 뿌리로 하는 부분 트리의 값 합을 출력한다.
- 두 번째 쿼리는 해당 노드의 값을 해당 부모의 노드 값으로 바꾸며, 그 부모 노드에 대해서 동일 작업을 반복한다. 최종적으로 루트 노드에는 쿼리로 주어진 두 번째 값을 넣는다.
- 그래프 크기는 최대 100,000 이며, 쿼리의 수 또한 최대 100,000이다.

## 입력양식
- `values`, `edges`, `queries` 가 입력으로 주어진다.
- `values` 는 정수의 배열로, 인덱스 `i`의 값은 `i+1`번 노드의 값을 의미한다. 0번 노드는 없다. 또한 1번 노드가 언제나 루트이다.
- `edges` 두 정수쌍의 배열로, 각 값은 해당 번호의 노드들이 연결되어 있음을 의미한다.
- `queries`는 두 정수쌍 `[u, w]`의 배열이다. 이는 순차적으로 노드에 작용한다.
  - `w`가 -1이라면 1번 쿼리로 `u`번 노드를 루트로 하는 부분트리의 값의 합을 출력에 넣어야 한다.
  - 나버지 경우에는 2번 쿼리로 `u`번 노드부터 해당 노드의 부모의 값으로 순차적으로 바꾼다. 최종적으로 루트 노드에서는 `w`의 값으로 바꾼다.
  
## 해설
- 자료 구조의 문제이다. 기본적으로 그냥 접근하면 무조건적인 시간초과가 된다.
- 나의 경우에는 공식 해설에서 추천한 treap과 HLD, 여기에 fenwick을 이용해서 작성하였다.
- 우선 입력의 연결상태를 모두 읽고, 1번 노드를 루트로 하는 트리를 만든다.
- 트리에서 부모가 아닌 연결된 노드, 즉 자식들을 선회하며 가장 긴 체인을 찾는다.
  - 자식이 없다면 자신의 값과 이를 이용한 길이 1짜리 체인을 반환한다. 이 체인은 treap의 형태로 이루어져 있다.
  - 자식이 있다면 함께 반환되는 값을 합쳐준다. 가장 긴 체인은 제외한다. 이는 이 체인의 해당 부분에 연결된 값으로 펜윅 방법으로 관리된다.
  - 가장 긴 체인에 자신의 값과 동일한 값을 갖는 노드를 만들어 treap의 형태로 추가한다. 추가된 노드는 순서상 마지막에 위치하도록 한다. 값의 합산과 체인을 반환한다.
- 체인을 treap 형태로 작성하는 방법은 다음과 같다.
  - 각 노드는 주어진 값, 그리고 해당 노드를 루트로 하는 서브트리의 모든 값의 합을 저장한다.
  - 각 노드는 무게를 저장한다. 해당 노드를 서브트리로 하는 트리의 노드의 수를 저장한다.
  - 각 노드는 무작위 난수값을 배정받는다. 부모노드는 언제나 자식노드보다 난수값이 크다. 최초 생성시에만 난수가 만들어진다.
  - 각 노드는 좌에서 우로, 그 순서가 유지된다. 중위선회의 방법으로 출력할 경우 그 순서는 체인에 값이 추가된 순서와 동일하다.
  - 마지막으로 주어진 노드의 번호와 체인을 이어주는 사전을 작성하고, 체인 내에서 노드의 번호가 체인의 몇 번째인지 이어주는 사전을 작성한다.
- 이제 기본 구조는 모두 완성했다. 쿼리의 처리만 작성하면 된다.
- 1번 쿼리의 경우는 그 서브트리의 합을 구해야 한다.
  - 우선 주어진 쿼리 값과 사전을 이용해서 해당 노드가 포함된 트립과 그 트립 내에서 몇 번째인지를 찾는다.
  - 체인이 기초 트리를 기준으로 볼 때에 0번에 말단이 위치하므로, 체인 기준으로 0번부터 찾아낸 번호까지의 노드 값의 합을 구해야 한다.
  - 서브트리 값 합산값과 무게를 이용해서 적절히 해당 노드까지의 값을 찾을 수 있다.
  - 해당 번호 이하의 체인에 연결된 값 또한 더해야 한다. 이는 펜윅을 이용해 만들어둔 자료로, 로그수준으로 빠르게 구할 수 있다.
- 2번 쿼리의 경우 노드의 삭제, 삽입이 필요하다.
  - 트립에서 해당 노드를 찾는다. 어떤 값이 삭제되는지 파악해두며, 해당 체인의 윗단의 값은 체인의 끝에 새로 생성되는 노드의 값으로 배정한다.
  - 노드의 삭제 시에는 순서가 유지되어야 한다. 해당 노드의 하위 값 중 순서가 작은 것과 큰 것이 존재한다.
  - 작은 것이 올라갈 경우, 해당 노드의 오른쪽과 기존의 순서가 큰 것의 난수값은 무엇이 더 작은지 확인해야 한다.
  - 난수가 더 큰 값이 언제나 위로 올라가며, 선택받지 못한 쪽은 다음 연결 후보가 된다.
  - 다른 후보는 올라간 노드의 안쪽 방향으로 연결된 것이다. 작은 것의 오른쪽, 혹은 큰 것의 왼쪽.
  - 후보 중 하나가 빈 노드라면 과정을 종료한다.
  - 동시에 위치가 상승한 노드는 새롭게 왼쪽 또는 오른쪽으로 연결된 노드에 대해서 값의 합과 무게를 더해준다.
  - 상위 단계에 팬윅으로 연결된 값은 새로 추가된 노드의 값에서 가장 아래 체인에서 사라진 값의 차만큼 변화한다.
  - 상위에 연결된 체인에 대해 동일한 방법으로 반복한다.

### 기법에 대한 주저리주저리
- 트리를 분해해서 다시 트립, 트리를 만든다는 발상은 혼자서 하기 어려운 발상이었다.
- 사실 한동안은 풀이를 보고도 풀지 못하던 문제였다.
- 트립의 개념이 흥미롭다. 난수 배정을 대체하려고 노력했으나 전혀 아니었다.
- 원래는 삭제-삽입의 순서로 이루어지지 않도록 유도했기에 관련 코드를 넣지 않았으나 실상은 2번 쿼리를 시도하는 과정에서 불가피하게 문제가 생가 찾기 함수를 만들었다.
- 정신줄 놓고 후반부 보완작업을 개판쳐놔서 코드가 너무 더럽다. 중복이 많다. 다듬을 여지가 많다.

## 풀이 후기
- 코드가 너무 더럽다.
- 마찬가지로 풀고 나니 어렵지는 않다. 익숙함의 문제인것 같다.
- 특정 경우에 대해서 애초에 오지 않도록 설계하겠다는 생각으로 취급할 여지를 주지 않는 것은 굉장히 안 좋은 방법이다.
- 빈 트리에 대해서 좀 더 잘 생각해 봐야겠다.
- 이진트리 기준 부모관계는 필수적이지 않다. 좌,우만 필요하기도 하다.
- 반복에서 약간만 달라지는 경우, 그 반복을 어떻게 잘 쓰는 방법이 없을까?
