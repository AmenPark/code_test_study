# 문자열의 아름다움
## 문제 설명
- 문자열이 하나 주어진다.
- 문자열의 아름다움을 문자열의 인덱스 `i` `j`에 대해 두 문자가 다를 때 `|j - i|`의 최대값이라고 정의하자.
- 주어진 문자열의 모든 부분 문자열에 대해 아름다움의 합을 구하여라

## 입력양식
- `s` 가 입력으로 들어온다.
- `s` 는 문자열이다.

## 해설
- 수학적으로 푼 문제다.
- 어떤 문자열의 아름다움은 시작문자와 끝 문자가 다르다면 그 길이가 된다.
- 시작 문자와 끝 문자가 같다면 문자열의 길이에서 시작 문자열의 연속된 길이와 끝 문자열의 연속된 길이 중 작은 것을 뺀 것이 아름다움이다.
- 문자에 대해서 동일 문자가 몇 번 반복되는 것이 몇 개 나오느냐에 따라서 아름다움 값이 달라진다.
- `a`가 10개라면 `a`로 시작해 `a`로 끝나는 부분 문자열이 `45`개 이므로 길이합 `n*(n-1) / 2` 에서 `45`만큼이 빠진다.
- `aa`로 시작해서 `aa`로 끝나는 경우에는 2만큼이 빠진다.
- 즉 모든 문자에 대해 연속으로 나오는 사전을 작성하고, 계산해주면 된다.
- 코드 기준으로는 문자열을 읽으면서 연속된 문자열에 대한 갯수에 대한 사전을 작성을 병행한다.
- 효율성 계산을 위해 연속된 문자열이 끝났을 때에 합산을 해 준다. `aabbaa`면 3번째 `b`를 받자마자 계산하는 것이 아닌 5번째 `a`를 받고 `b`에 대한 값을 더해준다.
- 기본적으로 길이 `n`인 부분문자열에 연속된 문자열 길이 `m`이 붙으면 `SUM(SUM(i | i = 1,2,...,k)| k = n+1, ... , n+m)`이 된다.
- 여기서 감소하는 값은 기본적으로 `m`개의 동일 문자열 내에서 발생하는 감소값이 존재한다.
- 추가로 연속 문자열 사전에서 최신 문자열의 연속 정보를 불러와서 빼 줘야 한다.
- 감소값은 `연속 문자열 나온 횟수 * SUM(S_i | S_i = 1,2,...)` 가 된다.
- 최신 문자열 길이와 과거 문자열 길이를 비교할 때 각 길이가 6, 4라면 이 값은 1,2,3,4,4,4이 된다. 최대 값은 4까지 증가하며 길이는 6인 수열이 되며,이 합산만큼 감소해야 한다.
- 시그마식을 잘 풀어쓰면 코드의 복잡한 수식이 나온다. 

## 기법에 대한 주저리주저리
- 너무 수학적으로 접근하여 풀었다. 프로그래머스 공식 해설지에 따르면 더 쉽게 풀 수 있는 듯 하다.
- 원래는 각 문자열의 인덱스 기준으로 코드를 작성했는데 효율성에서 문제가 있었다. 동일 문자열이 반복되면 한 번에 처리하는 방식으로 효율성을 통과했다.
- 그 과정에서 시그마가 한 번 더 씌워지면서 식이 과하게 복잡해졌다고 생각한다.

## 풀이 후기
- 프로그래머스에서 의도한 방식으로 코드를 짜 보는건 어떨까 싶기도 하다. 코드화하는것이 생각보다 쉽지는 않아보인다.

# 문제해결 2

## 개요
- 프로그래머스 레벨 5 테스트 중에 문제가 나왔다. 어떻게 풀까 고민하다가 새로운 방식으로 접근했는데, 생각보다 결과가 좋아서 업데이트했다.

## 해설
- 사실 기존과 동일한 아이디어에서 출발했다.
- 다만 정답의 증가량이 아니라 감소량에 주목했다.
- 부분문자열의 아름다움의 합에서 중요한 것은 양 끝의 연속된 문자열이 동일할 때, 그 문자열의 수가 각각 어떻게 되느냐 이지 부분문자열의 길이는 중요하지 않다.
- 따라서 일단 전체적으로 훑으며 연속 문자열에 대한 사전을 작성했다. 기존 풀이는 동시에 이 사전을 활용했는데, 이번 풀이는 사전 작성이 끝난 후 감산했다.
- 주요 정보는 다음과 같다.
  - 1. 문자열 전체에서 각 문자열이 몇 개 나왔는가?                   ex) aaaxxaaxa 면 'aaa', 'aa', 'a' 각각 3, 2, 1개로 총 6개이다.
  - 2. 문자열 전체에서 각 문자열에 대해 연속된 문자열이 총 몇 개인가?  ex) aaaxxaaxa 면 'aaa' , 'aa', 'a' 로 3개이다.
  - 3. 문자열 전체에서 각 문자열에 대해 각 연속된 문자열이 총 몇 개인가? ex) 동일예시 면 'a'는 3-1, 2-1, 1-1 개의 사전이 작성된다.
- 이후 문자열 전체를 순회한다. 
  - 각 순회마다 사전을 참조하여 가장 작은 값부터 3번 항목의 키 값을 작은 값부터 순회한다.
  - 위의 예를 보면 a 문자열에 대해 생각해 보면 주요 값은 다음과 같다. 6, 3, 1-1, 2-1, 3-1 이 주어진다.
  - 6, 3, 1에 대해서 생각해 보자.
    - 감소량은 6*5//2 이다. 정확히는 문자열의 수를 k라 할때 SUM(k * (k-1) // 2) 가 된다. 이는 적당히 고등학교 수학을 통해 계산 가능하다.
    - 이 때 sum의 범위는 이전 key와의 값 차이 deltakey의해서 range(deltakey)가 된다. 위의 경우에는 첫 key에 대해서는 deltaykey=key로 취급한다. 1이기 때문에 1번만 반영된다.
    - 만약 문자열이 aaaxxaaxxaa라면 첫 데이터는 7,3,2-2 가 된다. 이 경우에는 7 * (7-1)//2 + (7-3) * (7-3-1)//2 꼴로 f(7)+f(7-3)이 된다.
    - 즉, f(k) = k*(k-1)//2 일때, i = 0 , ... , deltakey 에 대해 감소량 = SUM(f(k-i)) where i = 0, ... deltakey 가 되는 것이다.
    - 이후 1번 사전에 있던 문자열 수에 대한 값은 2번 사전의 값 * deltakey 만큼 감소한다.
    - 2번 사전의 값은 3번 사전의 value 만큼 감소한다.
    - 해당 과정을 반복하면서 전체에서 빼준다.
  - 해당 논리가 적용되는 방법은 다음과 같다.
    - aaaabbaaaaabbaaaabbaababa 를 생각해 보자. 여기서 a 문자열을 생각해 보면, 4, 5, 4, 2, 1, 1개의 문자열이 연속해서 분포한다.
    - 즉, 입력으로 보자면 17, 6, 1-2, 2-1, 4-2, 5-1이 된다.
    - 임의의 두 개를 고르면 언제나 해당 부분문자열은 아름다움이 최소 1 감소되어 있다. -> 그만큼 빼 준다.
    - 17-6, 6-2로 각 값이 변환된다.
    - 이것은 각 연속문자열에서 a를 하나씩 지우는 효과이다. aaaaa, aaaa, aaaa, aa, a, a -> **aaaa**a, **aaa**a, **aaa**a, **aaa**a, **a**a, a, a
    - 물론 강조된 문자열에 a를 앞 또는 뒤에 붙일 수 있다. 이는 각각을 골라 잡을 때 왼쪽 끝이냐 오른쪽 끝이냐에 따라 달라진다. 
    - 다만 두 경우중 하나만이므로 따로 더 고려할 것은 아니다.
    - 이제 강조된 문자열 중 한 쌍을 고르면 아름다움의 감소량이 최소 2는 보장된다. 이미 1씩 빼 주었으므로, 그 숫자만큼 또 빼 준다.
    - 이를 반복한다.
  - 본 코드에서는 1-0, 2-0,3-0 ... 10-10 일 경우처럼 key가 연속으로 주어지지 않을 경우 연산을 최소화하기 위해 한번 더 압축한 케이스이다.
  - 그럼 전체 값은 어떻게 구하는가? 간단하다. f(N)을 N=0,...,len(s) 까지 다 더해주면 된다.
