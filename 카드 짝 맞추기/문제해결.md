# 카드 짝 맞추기
## 문제 설명
- 4x4 보드 위에 카드가 한 쌍씩 최대 8세트가 놓여져 있다. 동일한 카드 쌍을 선택하여 제거하는 방법으로 보드 위의 모든 카드를 제거할 때 필요한 입력의 최소 수를 구하는 문제이다.
- 입력은 이동, 선택의 두 종류가 있다. 이동은 일반 이동과 뛰어넘기 이동으로 나뉘며, 모두 하나의 입력으로 취급한다
- 선택은 현재 커서가 위치한 카드를 선택한다. 이전에 선택한 카드가 존재한다면 그 카드와 동일한 카드일 경우 제거하고 그렇지 않다면 모든 선택을 취소한다.
- 이동은 상,하,좌,우의 4방향이 존재하며, 한 칸만 이동과 카드를 만나거나 보드의 끝자락에 도달할 때 까지의 뛰어넘기 이동이 가능하다.

## 입출력양식
- `board	r	c` 의 인자가 들어온다.
- `board`
    - ``[[1,0,0,3],[2,0,0,0],[0,0,0,2],[3,0,1,0]]``
    - 2차원 형태로 입력. 0은 빈 장소, 나머지 정수는 카드를 의미하며 동일 정수는 한 쌍만 존재한다. 카드 수는 최대 6쌍.
- `r`, `c`
    - 현 위치를 의미한다. 4 이하의 정수.
- 출력은 정수. 최소입력수를 반환한다.

## 해설
- 너비우선 탐색은 어렵지 않다. 상태-방문기록-다음에 방문을 위한 기준점-방문을 위한 상태변환. 네 가지만 있다면 파이썬에서는 아주 간단하게 작성 가능하다.
- 다만 행동별 cost가 달라진다면 문제는 좀 더 복잡해진다.
- 초기값: 시작점. 그리고 cost 0.
- 반복문: 다음 시작점의 빈 리스트 생성. 시작점 리스트를 선회하며 다음 시작점을 탐색. 이미 dp로 방문기록이 잡혀있다면 스킵, 아니라면 다음 시작점에 넣는다. 이후 시작점 업데이트.
- 이후의 행동이 동일함이 분명하다면 dp를 사용해서 효율성을 올린다.

### 기법에 대한 주저리주저리
- 탐색의 코드를 짜는데 골치가 아프다면 각 행동에 대한 코드를 하나의 함수로 작성한 뒤에 생각해보면 문제가 좀 더 쉬워진다.
- 현 상태를 key로, 그에 따른 최소입력수를 value로 하는 dict를 만들면 dp 작성이 쉽다. 그 key를 잡기 어렵다면 최소입력수가 정해지는 모든 정보(문제의 경우에는 status와 커서의 좌표)를 dict에 넣을 수 있는 형태로 변환하는 일종의 인코더를 사용하면 편하다. 물론 인코딩 이후의 값이 같으면 동일 상태임이 확실해야 한다. 나의 경우에는 status.r.c꼴의 문자열로 변환하는 방법을 취했는데, 이 또한 더 좋은 방법이 있을 것이다.
- 카드쌍의 상태를 나타내는 좋은 방법은 2진법을 쓰는 것이다. 있음과 없음만 표시하면 되고, 위치는 고정이기 때문이다. 비트연산을 통해 탐색, 제거, 복원, 존재여부 판단 등이 가능해서 빠르고 편하다. 익숙하지 않거나 자료형, 혹은 데이터 크기에 의해서 문제의 소지는 있으나 시도해서 안 좋을 기법은 아니다.

## 풀이 후기
- 해당 문제는 나에게 굉장히 어렵게 다가왔는데 이는 나의 모든 경우를 다 시도하는 방법을 극단적으로 싫어하는 성향 때문이었다. 이 방법을 시도할 경우 최대 5만가지 경우의 수 미만으로, 상당히 적은 횟수로 답을 구할 수 있다.
- 완전한 최적화된 방법은 아니지만 나름대로의 고심을 해서 솔루션을 작성하였다. 다만 시간이 지나면서 귀차니즘으로 세세한 부분에서 하드코딩을 한 점 등 아쉬운 점이 존재한다. 또한 중복되는 부분을 함수로 따로 빼지 않은 점도 불편해 보인다.
- 탐색과 순회, 중복시 과감하게 스킵하는 것도 좋지만 중간에 이미 나온 최소 경우의 수보다 커질 경우 행동을 중단하고 다음 스텝으로 넘어가는 장치를 만드는 것도 좋아보인다.

