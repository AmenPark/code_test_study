# 트리 트리오 중간값
## 문제 설명
- 노드들이 트리의 형태로 연결되어 있다고 한다.
- 세 노드를 고르면 각 노드의 거리 3개가 나온다. 이 중에 중간값을 최대화하면 그 값은 어떻게 되는지 반환하라.

## 입력양식
- `n` `edges`의 인자가 들어온다.
- `n`은 정수이다.
- `edges`는 정수 두 쌍의 리스트 형태로 `[[1,3], [1,5], [4,2], ...]` 꼴이다.
  - `edges`는 트리이기 때문에 `n-1`개의 항목으로 구성되어 있으며, 각 항목은 해당 번호의 노드가 연결되어 있음을 의미한다.

## 해설
- 가장 긴 체인 위에서 양 끝 노드와 끝점에서 바로 인접한 노드 중 하나를 고르면 가장 긴 체인의 길이보다 하나 작은 만큼의 중간값이 보장됨을 알 수 있다.
- 트리에서 가장 긴 체인을 우선 찾아야 한다. 체인은 트리의 일부 노드를 골랐을 때 연결되어 있으며 각 노드는 하나 또는 두 개의 다른 노드와 연결되어 있어야 한다.
- 가장 긴 체인을 찾으면 해당 체인의 끝점을 루트로 잡아준다. 가장 긴 체인의 길이를 `l`이라 하자.
- 가장 긴 체인 위의 노드를 끝 점으로 하며 해당 체인과 겹치지 않는 체인을 찾아본다.
- 이 중 길이가 원점 기준 깊이가 `l`의 절반 이하라면 해당 깊이만큼을, 절반 이상이라면 `l`만큼의 깊이를 갖는 노드의 존재여부를 파악한다.
- 해당 노드가 존재한다면 `l`이 중간값의 최대이며, 그렇지 않다면 `l-1`이 된다.
- 가장 긴 체인을 제외하고 가장 긴 체인의 길이를 찾아 비교하는 것이 중요하다.

### 기법에 대한 주저리주저리
- 공식적으로 지원하는 해설에서는 트리의 중심을 잡고 원을 그려서 해결했다.
- 이 경우에는 가장 긴 체인의 한쪽 끝을 루트로 하는 경우에 비교하면, 두 갈래 체인을 제외하고 가장 긴 체인의 길이만을 알면 된다.
- 그냥 끝단의 깊이만 체크하면 되므로 이쪽이 훨씬 편한 방법이라고 생각한다.
- 그럼에도 사실 시간복잡도는 동일하다. 각 노드를 한번씩만 반복하기 때문이다. 그보다는 공간적인 면에서 차이가 있다고 생각한다.

## 풀이 후기
- 어렵지 않은 문제다. 다만 알고리즘보다는 효율성 때문에 애를 먹었다.
- 체인을 하나의 노드처럼 다루는 방법도 생각해 볼 수 있다. 가장 긴 체인을 하나의 노드로 바꾸는 것이다. 물론 이 문제는 그렇게 풀면 안 되지만.
