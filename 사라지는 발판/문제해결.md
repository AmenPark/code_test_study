# 지형 이동
## 문제 설명
- NxM의 보드판 위에 aloc, bloc에 플레이어 A,B가 각각 위치해 있다.
- 서로 번갈아 가며 상하좌우 4방향으로 발판이 존재할 경우 이동 가능하다.
- 상대가 존재하는 발판 위로 이동 가능
- 해당 플레이어의 차례에 자신이 밟고있는 발판이 없거나 이동할 발판이 없다면 패배한다.
- 각 플레이어는 승리한다면 짧게, 패배한다면 최대한 길게 게임을 이어가려고 한다.
- 두 플레이어가 최선의 전략을 선택할 경우 각 플레이어가 몇 번 이동했는지의 합을 반환하라.

## 입출력양식
- `board` `aloc` `bloc` 의 인자가 들어온다.
- `board`
    - ``[[1, 1, 1], [1, 1, 1], [1, 1, 1]]``
    - 2차원 형태로 입력. 1이면 발판이 존재하고, 0은 발판이 없음을 의미.
- `aloc`, `bloc`
    - `[1, 0]`과 같은 형태로 플레이어 a,b의 위치를 표시
- 출력은 정수. 최선의 전략으로 게임을 풀어갈 때에 게임의 길이를 의미한다.

## 해설
- 전형적인 탐색 문제이다. 나는 깊이 우선 탐색을 통해서 해당 문제를 해결하였다.
- 이후의 상황들 중 승리 가능한 경우가 있다면 그 중에서 가장 짧은 길이의 게임을 넘기고, 승리 가능한 경우가 없다면 가장 긴 길이의 게임을 넘긴다.
- 모든 경우를 탐색한 이후 남아있는 길이가 최종 답안이 된다.
- 코드에서는 길이 반환 과정에서 스택의 구조상 B의 위치정보가 없어진 상황에서 길이가 하나 더 증가하고 반복이 종료되기에 하나만큼 길이를 빼 주었다.

### 기법에 대한 주저리주저리
- dp요소가 있어보인다. 이전에 어떻게 움직였느냐 보다 현재 발판의 상태와 플레이어의 위치에 의해 게임이 결정되기 때문이다.
- 보드를 2진수로 바꾸는 인코딩을 통해 dp를 활용 가능할지도?

## 풀이 후기
- 틀 잡기가 생각만큼 쉽지 않았다. 코드에 오류를 잡는데 한참 애 먹었다.
- 오랜 시간 고생한 이유가 탐색의 방법 때문이었다. 보드의 제거와 재건의 과정에서 탐색 불가능한 지형이 탐색 가능하게 되면서 생기는 무한루프 문제가 있었다.
- 두 개의 객체라고 생각하지 말고 하나의 게임의 흐름이라는 관점으로 보는 것이 기존의 개념처럼 생각을 편하게 만든다.
