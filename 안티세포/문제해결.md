# 안티세포
## 문제 설명
- 자연수로 이루어진 배열 `b`가 주어진다.
- 각 수들은 하나의 세포로 둘러쌓여 있다. 이 세포들은 인접한 것 끼리 합쳐지거나 그대로 있을 수 있다. 이를 통해 배열 `c`를 만든다.
  - 빈 배열 `c`를 만든다. 배열을 앞에서부터 세포를 확인한다. 마지막 세포의 확인 및 연관 행동 후에는 `c` 만들기를 종료한다.
  - 중간에 `i`번째 세포에서 해당 값을 포함하는 세포를 `X`라 하고, 바로 왼쪽의 세포를 `Y`라 하면, `X` 내 숫자의 합과 `Y` 내 숫자의 합이 같을 때 합치거나, 합치지 않을 수 있다.
  - 합칠 경우 `c`에 `i`가 추가된다. 합치기가 추가로 가능하다면 계속 `i`의 추가가 가능하며, 아니라면 이어서 다음 값을 탐색한다.
  - 합치지 않는 경우에는 `c`에는 변동이 없다.
- 해당 과정을 통해 다양한 `c`가 만들어질 수 있다. `b`가 여럿 주어질 때, 각 `b`에 대응하는 `c`의 갯수가 각각 몇 개인지 출력하시오.
  
## 입력양식
- `a` `s` 가 입력으로 주어진다.
- `a` 는 자연수의 리스트로 문제의 `b`를 이어붙인 것이다.
- `s`는 자연수의 리스트로 문제의 각 `b`에 대해 그 리스트 크기를 기록한 것이다.

## 해설
- dp 문제이다.
- 우선 `a`를 `s` 크기로 잘라주며 `b`를 생성한다.
- 이후 각 `b`에 대해 `c`의 수를 세서 답을 작성하면 된다.
- 모든 세포는 크기 1로 시작한다. 각 세포는 `b`에서 언제나 연속된 값을 감싸고 있다.
- 값을 기록할 때 중요한 것은 `i`번째까지 탐색했을 때 몇 가지 종류의 `c`가 존재하느냐이다. 그리고 가장 최근의 세포 `X`가 어디까지 감싸고 있느냐이다.
  - 나의 경우에는 `record := [{var : (n, j)}]`꼴로 사전을 작성해서 기록했다.
  - 인덱스 `i`는 세포 `X`의 오른쪽 끝 값 인덱스, `var`은 `X` 내부 값의 합, `j`는 해당 세포가 `X`에 편입 시 다음 탐색해야할 `Y`의 위치(`i`의 값에 대응)이다.
- 이제 `i=0`일때, 초기 상태는 1가지로 `[b[0] : (1, None)]` 이다. `None`은 해당 값이 `X`로 편입된 이후 `Y`가 존재하지 않기 때문이다.
- 이후에 `i`를 중가시키며 `record`에 대해 값을 작성한다. 기본적으로 이전 단계에서 방치하는 것 만으로 한 가지 가짓수가 존재하므로 이전 단계의 경우의 수의 합을 그대로 갖는다.
- 추가적으로 합치는 것이 가능하다면 `record[i]` 의 사전에 `var = b[i] * 2^k (k=0)` 꼴의 키 값에 대응하여, 이전 `j (i-1)` 기준 최근 `X`의 합이 `var`과 같은 경우의 수 만큼 증가한다.
- 이는 최근 `X`의 합이 두 배가 되는 것으로 새로운 키에 대한 값 쌍을 `record[i]` 사전에 추가해야 한다. `X`의 크기가 커진만큼 `j` 값 또한 적절하게 변화한다.
- 위의 과정이 불가능해질 때 까지 반복한다.
- 최종 경우의 수, `record[-1]`에 대해 모든 `value`값의 합이 `c`의 갯수이다.

### 기법에 대한 주저리주저리
- `Y`는 이전에 `X`였던적이 있다는 것을 깨달아야 하는 문제였다.
- 복잡하고 더러워 보였는데, 생각보다 코드가 줄어들었다.
- dp를 이런 사전의 리스트 형식으로 구현하기보다 class로 만드는 것도 좋아보인다.

## 풀이 후기
- 깔끔한 방식은 아니라고 본다.
- 다른 사람이 코드를 볼 때 이해할 수 있을까? 어렵지 않을까?
- 직관적으로 이해하기 좋은 코드 짜는 방법을 연구해 봐야 할 것 같다.
