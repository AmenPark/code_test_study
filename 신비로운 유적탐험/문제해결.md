# 신비로운 유적탐험
## 문제 설명
- 같은 트리의 부분트리인 두 트리가 주어진다. 루트가 동일 노드임이 확실할 때, 두 트리 모두에 포함된 서브트리가 가장 크게 했을 때의 값을 반환하라. 트리에는 부모-자식 관계만 존재한다.

## 입출력양식
- `n1` `g1` `n2` `g2`가 입력으로 들어온다.
- `n1`과 `n2`는 각각 트리의 노드 숫자이다.
- `g1`과 `g2`는 각 트리의 두 노드가 연결됨을 나타낸다.

## 해설
- 재귀, dp, mcmf로 접근해야 하는 문제다.(그렇지 않으면 시간초과가 난다.)
- 각 트리에서 노드를 하나씩 골라 a,b라 하면 a와 b를 루트로 하는 서브트리의 유사도를 구해야 한다.
- 이는 a의 자식 노드들과 b의 자식 노드들을 적당히 매칭해서, 그 유사도 합이 최대한 크게 해야 한다.
- a 또는 b가 자식이 없다면 유사도는 1이며, 그렇지 않다면 유사도 합을 최대로 했을 때의 값 + 1이 a와 b의 유사도가 된다.
- 자식은 재귀로 구했다면, 주 알고리즘은 source와 sink 노드를 만들어, source는 a의 모든 자식으로 갈 수 있고(cost=0), a의 모든 자식은 b의 모든 자식으로 갈 수 있고(cost는 ai와 bi의 유사도), b의 모든 자식은 sink로 갈 수 있다.(cost=0) 그리고 mcmf를 하면 끝.

### 기법에 대한 주저리주저리
- 개념상으로 복잡하다. 왜 그 알고리즘이 성립하는가를 파고들어서 매우 골치아팠다.
- 플로우 개념을 모르는 문외한이라면 브루트포스 혹은 그 개량을 시도하다가 시간초과가 날 것이다.

## 풀이 후기
- 머리아픈 문제였다. java를 써서 풀었기 때문에 더 머리아팠던것 같다.
- 공부하면서 플로우 개념을 좀 다잡은것 같아서 뿌듯하긴 하다.
- 왜 제대로 작동하는가가 굉장히 와닿지 않아서 문제였는데, 산책과 꿀잠을 병행하면 당신도 이해할 수 있다.
