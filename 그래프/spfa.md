# spfa란?
  - spfa는 shortest path faster algorithm의 줄임말이다.
  - 음수 간선이 있는 그래프의 다익스트라 버전이라고 생각하면 된다.

# 사실 진짜 열화버전은 벨만-포드라고 있다.
  - 알고리즘은 간단하다. 모든 간선으로 정점숫자만큼 반복하면서 인근 정점의 정보를 갱신하는 것이다.
  - 굉장히 무식한 방법이다. 좀 더 개량하면, 이전 단계에서 갱신된 정점에 대해서만 정보를 갱신할 수 있는 정도일 것이다.
  - 음의 사이클은 갱신을 전체 정점 숫자 이상 반복 가능할 경우 있다고 판단 가능하다.(각 갱신은 한 번의 움직임이며, 전체 정점만큼 반복했으므로 비둘기집 원리로 어딘가 정점을 두 번 반복한 것이다. 갱신 기준은 코스트가 적은 쪽이므로, 음의 사이클이 존재한다.)

# spfa의 구현은?
  - 다익스트라의 경우는 기존 일반적인 탐색의 자료구조를 우선순위큐로 바꾸는 수준이었다.
  - spfa의 경우에는 그냥 큐를 쓰며(사실 큐가 아니라 다른 자료구조도 상관없으나 큐가 제일 효율적일 것이다.) 갱신할 때 큐에 중복해서 넣을 필요가 없으므로 inQ같은 멤버변수를 하나 추가해주는게 좋다.
  - 큐가 빌 때까지 탐색하면 끝이나, 아무래도 음의 사이클이 생기는 것이 문제이다. 이 경우는, 각 정점에 갱신숫자를 따로 두고, 갱신 숫자가 전체 정점 수를 넘어가는 순간 음의 사이클이 존재한다고 판단한다.
  - 즉, 알고리즘은 다음과 같다.

## 구현하기(JAVA)
```
...
public boolean spfa(NodeForSearch source, NodeForSearch sink){
        Queue<NodeForSearch> queue=new LinkedList<>();  // 큐 생성
        queue.add(source);                              // 시작점을 큐에 넣는다.
        source.costSum=0;                               // 시작점 코스트를 0으로 둔다. 다른지점은 무한(또는 충분히 큰 수)
        source.inQ=true;                                // 시작점은 큐에 들어갔다고 알린다.
        NodeForSearch now=null;
        while(queue.size()>0){                          // 큐가 비지 않았으면 반복
            now = queue.poll();                             // 큐에서 하나 꺼내기
            for(Tp tp:now.conn){                            // 꺼낸 노드와 연결된 간선을 꺼내기
                if (tp.to.costSum>now.costSum+tp.cost){    // 연결된 간선의 도착점의 기존 코스트가 현재 노드의 코스트+간선코스트보다 크면
                    tp.to.costSum=now.costSum+tp.cost;      // 갱신
                    tp.to.from=tp;                          // 이건 경로를 추적하기 위한 코드이다.
                    if (!tp.to.inQ){                        // 큐에 갱신된 노드가 들어있는지 파악해서 넣기
                        tp.to.inQ=true;
                        queue.add(tp.to);
                    }
                }
            }
            now.inQ=false;                                  // 갱신완료. 큐에서 빼기.
        }
        if (sink.costSum<INF){                              // 대략 정의한 무한값보다 sink의 코스트가 작으면 갱신된 것이므로 true, 아님 false 반환.
            return true;
        }else{
            return false;
        }
}
```
파이썬으로 짜면 더 쉬운 코드가 나오는데, 이걸 처음 짠 문제가 파이썬 언어가 미지원이라..
해당 코드는 음의 사이클이 있으면 무한루프가 생긴다. 판별하는걸 넣지 않았으며, 역추적을 위한 것만 넣었다.
역추적이 하나만 존재하는 이유는, 사이클이 존재하지 않는 한 하나의 정점에는 경로상 한 번만 방문하기 때문이다.



  
